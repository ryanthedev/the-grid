#!/bin/bash

# Grid CLI Wrapper Script
# Provides easy access to grid-cli with auto-build, server management, and health checks

set -e

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CLI_BINARY="$SCRIPT_DIR/grid-cli/bin/grid"
SERVER_BINARY="$SCRIPT_DIR/grid-server/.build/debug/grid-server"
SOCKET_PATH="/tmp/grid-server.sock"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Check if CLI binary exists, build if needed
ensure_cli_built() {
    if [ ! -f "$CLI_BINARY" ]; then
        echo -e "${YELLOW}Grid CLI binary not found. Building...${NC}"
        cd "$SCRIPT_DIR" && make cli
        echo -e "${GREEN}Build complete!${NC}"
    fi
}

# Check dependencies
check_dependency() {
    local cmd="$1"
    local name="$2"
    local install_hint="$3"

    if ! command -v "$cmd" &>/dev/null; then
        echo -e "${RED}Error: $name is not installed${NC}"
        echo -e "${YELLOW}Install it with: $install_hint${NC}"
        exit 1
    fi
}

check_fzf_deps() {
    check_dependency "fzf" "fzf" "brew install fzf"
    check_dependency "jq" "jq" "brew install jq"
}

# Check if server is running
is_server_running() {
    if [ -S "$SOCKET_PATH" ]; then
        # Socket exists, try to ping
        "$CLI_BINARY" ping &>/dev/null
        return $?
    else
        return 1
    fi
}

# Server management commands
server_start() {
    if is_server_running; then
        echo -e "${GREEN}Server is already running${NC}"
        return 0
    fi

    if [ ! -f "$SERVER_BINARY" ]; then
        echo -e "${YELLOW}Server binary not found. Building...${NC}"
        cd "$SCRIPT_DIR" && make build
    fi

    echo -e "${GREEN}Starting grid-server...${NC}"
    "$SERVER_BINARY" &

    # Wait for server to be ready
    sleep 1
    if is_server_running; then
        echo -e "${GREEN}Server started successfully${NC}"
    else
        echo -e "${RED}Failed to start server${NC}"
        return 1
    fi
}

server_stop() {
    if ! is_server_running; then
        echo -e "${YELLOW}Server is not running${NC}"
        return 0
    fi

    echo -e "${YELLOW}Stopping grid-server...${NC}"
    pkill -f grid-server || true
    sleep 0.5

    if ! is_server_running; then
        echo -e "${GREEN}Server stopped${NC}"
    else
        echo -e "${RED}Failed to stop server${NC}"
        return 1
    fi
}

server_status() {
    if is_server_running; then
        echo -e "${GREEN}Server is running${NC}"
        "$CLI_BINARY" ping
    else
        echo -e "${RED}Server is not running${NC}"
        if [ -S "$SOCKET_PATH" ]; then
            echo -e "${YELLOW}Socket file exists but server is unresponsive${NC}"
        fi
        return 1
    fi
}

# ============================================================================
# fzf Integration Functions
# ============================================================================

# Select a window using fzf
fzf_select_window() {
    local multi="${1:-false}"
    local header="${2:-Select window}"

    if [ "$multi" = "true" ]; then
        "$CLI_BINARY" list windows --json | \
            jq -r '.[] | "\(.id)\t\(.appName // "?")\t\(.title // "Untitled")\tSpace: \(.spaces[0] // "?")"' | \
            fzf --multi \
                --header="$header (TAB to select multiple, ENTER to confirm)" \
                --delimiter='\t' \
                --with-nth=2,3,4 \
                --preview="echo {} | cut -f1 | xargs -I {} $CLI_BINARY window get {} --json 2>/dev/null | jq ." \
                --preview-window=right:50% | \
            cut -f1
    else
        "$CLI_BINARY" list windows --json | \
            jq -r '.[] | "\(.id)\t\(.appName // "?")\t\(.title // "Untitled")\tSpace: \(.spaces[0] // "?")"' | \
            fzf --header="$header" \
                --delimiter='\t' \
                --with-nth=2,3,4 \
                --preview="echo {} | cut -f1 | xargs -I {} $CLI_BINARY window get {} --json 2>/dev/null | jq ." \
                --preview-window=right:50% | \
            cut -f1
    fi
}

# Select a space using fzf
fzf_select_space() {
    local header="${1:-Select space}"

    "$CLI_BINARY" list spaces --json | \
        jq -r '.[] | "\(.id)\t\(.type)\t\(if .isActive then "★ ACTIVE" else "" end)\tDisplay: \(.displayUUID[0:8])"' | \
        fzf --header="$header" \
            --delimiter='\t' \
            --with-nth=1,2,3,4 \
            --preview="echo {} | cut -f1 | xargs -I {} $CLI_BINARY list windows --json 2>/dev/null | jq '[.[] | select(.spaces | contains([{} | tonumber]))] | \"Windows on space {}: \" + (. | length | tostring)' -r && echo {} | cut -f1 | xargs -I {} $CLI_BINARY list windows --json 2>/dev/null | jq -r '[.[] | select(.spaces | contains([{} | tonumber]))] | .[] | \"  - \(.appName // \"?\"): \(.title // \"Untitled\")\"'" \
            --preview-window=right:50% | \
        cut -f1
}

# Select a display using fzf
fzf_select_display() {
    local header="${1:-Select display}"

    "$CLI_BINARY" list displays --json | \
        jq -r '.[] | "\(.uuid)\t\(.name)\t\(.pixelWidth)x\(.pixelHeight)\t\(if .isMain then "★ Main" else "" end)"' | \
        fzf --header="$header" \
            --delimiter='\t' \
            --with-nth=2,3,4 \
            --preview="echo {} | cut -f1 | xargs -I {} $CLI_BINARY list displays --json 2>/dev/null | jq '.[] | select(.uuid == \"{}\")'" \
            --preview-window=right:50% | \
        cut -f1
}

# ============================================================================
# fzf Commands
# ============================================================================

fzf_cmd_select_window() {
    fzf_select_window false "Select window (output: window ID)"
}

fzf_cmd_move_window() {
    echo -e "${YELLOW}Step 1/2: Select window to move${NC}"
    local win_id
    win_id=$(fzf_select_window false "Select window to move")

    if [ -z "$win_id" ]; then
        echo -e "${RED}No window selected${NC}"
        return 1
    fi

    echo -e "${YELLOW}Step 2/2: Select destination space${NC}"
    local space_id
    space_id=$(fzf_select_space "Select destination space")

    if [ -z "$space_id" ]; then
        echo -e "${RED}No space selected${NC}"
        return 1
    fi

    echo -e "${GREEN}Moving window $win_id to space $space_id...${NC}"
    "$CLI_BINARY" window to-space "$win_id" "$space_id"
}

fzf_cmd_to_display() {
    echo -e "${YELLOW}Step 1/2: Select window to move${NC}"
    local win_id
    win_id=$(fzf_select_window false "Select window to move")

    if [ -z "$win_id" ]; then
        echo -e "${RED}No window selected${NC}"
        return 1
    fi

    echo -e "${YELLOW}Step 2/2: Select destination display${NC}"
    local display_uuid
    display_uuid=$(fzf_select_display "Select destination display")

    if [ -z "$display_uuid" ]; then
        echo -e "${RED}No display selected${NC}"
        return 1
    fi

    echo -e "${GREEN}Moving window $win_id to display $display_uuid...${NC}"
    "$CLI_BINARY" window to-display "$win_id" "$display_uuid"
}

fzf_cmd_center_window() {
    local win_id
    win_id=$(fzf_select_window false "Select window to center")

    if [ -z "$win_id" ]; then
        echo -e "${RED}No window selected${NC}"
        return 1
    fi

    echo -e "${GREEN}Centering window $win_id...${NC}"
    "$CLI_BINARY" window center "$win_id"
}

fzf_cmd_switch_space() {
    local space_id
    space_id=$(fzf_select_space "Switch to space")

    if [ -z "$space_id" ]; then
        echo -e "${RED}No space selected${NC}"
        return 1
    fi

    echo -e "${GREEN}Switching to space $space_id...${NC}"
    "$CLI_BINARY" space focus "$space_id"
}

fzf_cmd_opacity() {
    echo -e "${YELLOW}Step 1/2: Select window${NC}"
    local win_id
    win_id=$(fzf_select_window false "Select window for opacity adjustment")

    if [ -z "$win_id" ]; then
        echo -e "${RED}No window selected${NC}"
        return 1
    fi

    echo -e "${YELLOW}Step 2/2: Select opacity level${NC}"
    local opacity
    opacity=$(echo -e "1.0 (Opaque)\n0.9\n0.8\n0.7\n0.6\n0.5\n0.4\n0.3\n0.2\n0.1\n0.0 (Transparent)" | \
        fzf --header="Select opacity level" | awk '{print $1}')

    if [ -z "$opacity" ]; then
        echo -e "${RED}No opacity selected${NC}"
        return 1
    fi

    echo -e "${GREEN}Setting window $win_id opacity to $opacity...${NC}"
    "$CLI_BINARY" window set-opacity "$win_id" "$opacity"
}

fzf_cmd_layer() {
    echo -e "${YELLOW}Step 1/2: Select window${NC}"
    local win_id
    win_id=$(fzf_select_window false "Select window for layer adjustment")

    if [ -z "$win_id" ]; then
        echo -e "${RED}No window selected${NC}"
        return 1
    fi

    echo -e "${YELLOW}Step 2/2: Select layer${NC}"
    local layer
    layer=$(echo -e "above\nnormal\nbelow" | \
        fzf --header="Select window layer")

    if [ -z "$layer" ]; then
        echo -e "${RED}No layer selected${NC}"
        return 1
    fi

    echo -e "${GREEN}Setting window $win_id layer to $layer...${NC}"
    "$CLI_BINARY" window set-layer "$win_id" "$layer"
}

fzf_cmd_sticky() {
    local win_id
    win_id=$(fzf_select_window false "Select window to toggle sticky")

    if [ -z "$win_id" ]; then
        echo -e "${RED}No window selected${NC}"
        return 1
    fi

    # Check current sticky status
    local is_sticky
    is_sticky=$("$CLI_BINARY" window is-sticky "$win_id" 2>/dev/null | grep -q "true" && echo "true" || echo "false")

    if [ "$is_sticky" = "true" ]; then
        echo -e "${GREEN}Disabling sticky for window $win_id...${NC}"
        "$CLI_BINARY" window set-sticky "$win_id" false
    else
        echo -e "${GREEN}Enabling sticky for window $win_id...${NC}"
        "$CLI_BINARY" window set-sticky "$win_id" true
    fi
}

fzf_cmd_batch_move() {
    echo -e "${YELLOW}Step 1/2: Select windows to move${NC}"
    local win_ids
    win_ids=$(fzf_select_window true "Select windows to move")

    if [ -z "$win_ids" ]; then
        echo -e "${RED}No windows selected${NC}"
        return 1
    fi

    echo -e "${YELLOW}Step 2/2: Select destination space${NC}"
    local space_id
    space_id=$(fzf_select_space "Select destination space")

    if [ -z "$space_id" ]; then
        echo -e "${RED}No space selected${NC}"
        return 1
    fi

    echo -e "${GREEN}Moving windows to space $space_id...${NC}"
    echo "$win_ids" | while read -r win_id; do
        echo -e "  ${GREEN}→${NC} Moving window $win_id"
        "$CLI_BINARY" window to-space "$win_id" "$space_id"
    done
    echo -e "${GREEN}Done!${NC}"
}

fzf_cmd_batch_opacity() {
    echo -e "${YELLOW}Step 1/2: Select windows${NC}"
    local win_ids
    win_ids=$(fzf_select_window true "Select windows for opacity adjustment")

    if [ -z "$win_ids" ]; then
        echo -e "${RED}No windows selected${NC}"
        return 1
    fi

    echo -e "${YELLOW}Step 2/2: Select opacity level${NC}"
    local opacity
    opacity=$(echo -e "1.0 (Opaque)\n0.9\n0.8\n0.7\n0.6\n0.5\n0.4\n0.3\n0.2\n0.1\n0.0 (Transparent)" | \
        fzf --header="Select opacity level" | awk '{print $1}')

    if [ -z "$opacity" ]; then
        echo -e "${RED}No opacity selected${NC}"
        return 1
    fi

    echo -e "${GREEN}Setting opacity to $opacity for selected windows...${NC}"
    echo "$win_ids" | while read -r win_id; do
        echo -e "  ${GREEN}→${NC} Setting window $win_id"
        "$CLI_BINARY" window set-opacity "$win_id" "$opacity"
    done
    echo -e "${GREEN}Done!${NC}"
}

fzf_cmd_batch_layer() {
    echo -e "${YELLOW}Step 1/2: Select windows${NC}"
    local win_ids
    win_ids=$(fzf_select_window true "Select windows for layer adjustment")

    if [ -z "$win_ids" ]; then
        echo -e "${RED}No windows selected${NC}"
        return 1
    fi

    echo -e "${YELLOW}Step 2/2: Select layer${NC}"
    local layer
    layer=$(echo -e "above\nnormal\nbelow" | \
        fzf --header="Select window layer")

    if [ -z "$layer" ]; then
        echo -e "${RED}No layer selected${NC}"
        return 1
    fi

    echo -e "${GREEN}Setting layer to $layer for selected windows...${NC}"
    echo "$win_ids" | while read -r win_id; do
        echo -e "  ${GREEN}→${NC} Setting window $win_id"
        "$CLI_BINARY" window set-layer "$win_id" "$layer"
    done
    echo -e "${GREEN}Done!${NC}"
}

# Handle fzf subcommands
if [ "$1" = "fzf" ]; then
    ensure_cli_built
    check_fzf_deps

    case "$2" in
        # Window selection and movement
        select-window)
            fzf_cmd_select_window
            ;;
        move-window|move)
            fzf_cmd_move_window
            ;;
        to-display)
            fzf_cmd_to_display
            ;;
        center-window|center)
            fzf_cmd_center_window
            ;;

        # Space switching
        switch-space|switch)
            fzf_cmd_switch_space
            ;;

        # Opacity and layer control
        opacity)
            fzf_cmd_opacity
            ;;
        layer)
            fzf_cmd_layer
            ;;
        sticky)
            fzf_cmd_sticky
            ;;

        # Batch operations
        batch-move)
            fzf_cmd_batch_move
            ;;
        batch-opacity)
            fzf_cmd_batch_opacity
            ;;
        batch-layer)
            fzf_cmd_batch_layer
            ;;

        # Help
        help|--help|-h|"")
            cat << EOF
${GREEN}Grid fzf Commands${NC}

${YELLOW}Window Selection & Movement:${NC}
  select-window         Select a window and output its ID
  move-window, move     Select window and move to space
  to-display            Select window and move to display
  center-window, center Select window and center it

${YELLOW}Space Switching:${NC}
  switch-space, switch  Fuzzy search and switch to space

${YELLOW}Opacity & Layer Control (requires MSS):${NC}
  opacity               Select window and set opacity
  layer                 Select window and set layer (above/normal/below)
  sticky                Select window and toggle sticky

${YELLOW}Batch Operations:${NC}
  batch-move            Select multiple windows and move to space
  batch-opacity         Select multiple windows and set opacity
  batch-layer           Select multiple windows and set layer

${YELLOW}Examples:${NC}
  $0 fzf move           # Interactive window mover
  $0 fzf switch         # Quick space switcher
  $0 fzf opacity        # Adjust window transparency
  $0 fzf batch-move     # Move multiple windows at once
EOF
            ;;
        *)
            echo -e "${RED}Unknown fzf command: $2${NC}"
            echo "Run '$0 fzf help' for available commands"
            exit 1
            ;;
    esac
    exit $?
fi

# Handle server subcommands
if [ "$1" = "server" ]; then
    ensure_cli_built

    case "$2" in
        start)
            server_start
            ;;
        stop)
            server_stop
            ;;
        status)
            server_status
            ;;
        restart)
            server_stop
            server_start
            ;;
        *)
            echo "Usage: $0 server {start|stop|status|restart}"
            exit 1
            ;;
    esac
    exit $?
fi

# For all other commands, ensure binary is built
ensure_cli_built

# Check server health for regular CLI commands (except help/version)
if [ "$1" != "--help" ] && [ "$1" != "-h" ] && [ "$1" != "--version" ] && [ "$1" != "-v" ]; then
    if ! is_server_running; then
        echo -e "${RED}Warning: Server is not running!${NC}"
        echo -e "${YELLOW}Start the server with: $0 server start${NC}"
        echo ""
    fi
fi

# Forward all arguments to the actual CLI binary
exec "$CLI_BINARY" "$@"
